#! /bin/bash
# Don't wait for job termination notification
# set -o notify

# Don't use ^D to exit
# set -o ignoreeof

# Use case-insensitive filename globbing
shopt -s nocaseglob

# Use hidden file globbing
shopt -s cmdhist

# Make bash append rather than overwrite the history on disk
shopt -s histappend

# When changing directory small typos can be ignored by bash
# for example, cd /vr/lgo/apaache would find /var/log/apache
shopt -s cdspell

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# save multi-line commands as one history entry
shopt -s cmdhist

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set up prompt
function prompt_command() {
	# remember exit code for coloring
	exitCode=$?

	# setup colors for solarized
	if tput setaf 1 &> /dev/null; then
		tput sgr0
		TPUTCOLORS=$(tput colors)
		if [[ $TPUTCOLORS -ge 256 ]]; then
			BASE03=$(tput setaf 234)
			BASE02=$(tput setaf 235)
			BASE01=$(tput setaf 240)
			BASE00=$(tput setaf 241)
			BASE0=$(tput setaf 244)
			BASE1=$(tput setaf 245)
			BASE2=$(tput setaf 254)
			BASE3=$(tput setaf 230)
			YELLOW=$(tput setaf 136)
			ORANGE=$(tput setaf 166)
			RED=$(tput setaf 160)
			MAGENTA=$(tput setaf 125)
			VIOLET=$(tput setaf 61)
			BLUE=$(tput setaf 33)
			CYAN=$(tput setaf 37)
			GREEN=$(tput setaf 64)
		elif [[  TPUTCOLORS -ge 16 ]]; then
			# 16 colors available
			BASE03=$(tput setaf 8)
			BASE02=$(tput setaf 0)
			BASE01=$(tput setaf 10)
			BASE00=$(tput setaf 11)
			BASE0=$(tput setaf 12)
			BASE1=$(tput setaf 14)
			BASE2=$(tput setaf 7)
			BASE3=$(tput setaf 15)
			YELLOW=$(tput setaf 3)
			ORANGE=$(tput setaf 9)
			RED=$(tput setaf 1)
			MAGENTA=$(tput setaf 5)
			VIOLET=$(tput setaf 13)
			BLUE=$(tput setaf 4)
			CYAN=$(tput setaf 6)
			GREEN=$(tput setaf 2)
		else
			# hmm, less than 16 colors
			# let's try with one of the 5 color palette modes:
			# base02, base1, base2, magenta, violet
			BASE03=
			BASE02=$(tput setaf 0)
			BASE01=
			BASE00=
			BASE0=
			BASE1=$(tput setaf 14)
			BASE2=$(tput setaf 7)
			BASE3=
			YELLOW=
			ORANGE=
			RED=
			MAGENTA=$(tput setaf 5)
			VIOLET=$(tput setaf 13)
			BLUE=
			CYAN=
			GREEN=
		fi
		BOLD=$(tput bold)
		RESET=$(tput sgr0)
		CLEAREOL=$(tput el)
		PROMPTBG=$(tput setab 0)
	else
		# no tput, let's try with ansi escape sequences
		BASE03="\033[0;90m" # br black
		BASE02="\033[0;30m" # black
		BASE01="\033[0;92m" # br green
		BASE00="\033[0;93m" # br yellow
		BASE0="\033[0;94m" # br blue
		BASE1="\033[0;96m" # br cyan
		BASE2="\033[1;37m" # white
		BASE3="\033[0;97m" # br white
		YELLOW="\033[0;33m"
		ORANGE="\033[1;91m"
		RED="\033[0;31m"
		MAGENTA="\033[0;35m"
		VIOLET="\033[0;95m" # br magenta
		BLUE="\033[0;34m"
		CYAN="\033[0;36m"
		GREEN="\033[0;32m"
		WHITE="\033[1;37m"
		BOLD=""
		RESET="\033[m"
		CLEAREOL="\033[K"
		PROMPTBG="\033[0;0;30m"
	fi

	TIME="\A"
	BRANCH="\$(type -t __git_ps1 &> /dev/null && __git_ps1 '[%s] ')"
	DISPLAYPATH="\w"
	# red color for  root
	if [ $UID -eq 0 ]; then
		USER_HOST="\[${RED}\]\u@\h"
	else
		USER_HOST="\[${CYAN}\]\u@\h"
	fi

	# red exit code and dollar prompt if non-zero
	if [[ $exitCode -ne 0 ]]; then
		EXIT_CODE="\[${RED}\]($exitCode) "
		DOLLAR="\[${RED}\]\$ "
	else
		EXIT_CODE=""
		DOLLAR="\$ "
	fi

	# set the prompt
	export PS1="\[${RESET}${PROMPTBG}${BASE1}\]\A ${USER_HOST} ${EXIT_CODE}\[${BLUE}\]${BRANCH}\[${ORANGE}\]${DISPLAYPATH}\[${CLEAREOL}${RESET}\]\n\[${RESET}\]${DOLLAR}\[${BASE0}${RESET}\]"

	# quick color test with echo $TESTCOLOR
	export TESTCOLOR="${BASE03}BASE03 ${BASE02}BASE02 ${BASE01}BASE01 ${BASE3}BASE00 ${BASE2}BASE2 ${BASE1}BASE1 ${BASE0}BASE0 ${YELLOW}YELLOW ${ORANGE}ORANGE ${RED}RED ${MAGENTA}MAGENTA ${VIOLET}VIOLET ${BLUE}BLUE ${CYAN}CYAN ${GREEN}GREEN "
}

# Whenever displaying the prompt, write the previous line to disk (-a) and read
# the new line into the history list (-n)
export PROMPT_COMMAND="prompt_command; history -a; history -n; ${PROMPT_COMMAND}"

